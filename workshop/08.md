# FastAPI server

## Hello world

FastAPI is an easy-to-use web framework for building APIs with Python.

It's built on Starlette and Pydantic. Starlette is a lightweight HTTP framework, and Pydantic
provides the data modelling.

Create a file `api.py`:

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def index():
    return {"message": "Hello world"}
```

Now run `fastapi dev api.py` and you should see the FastAPI dev server running.

Open `http://localhost:8000` in a browser and you should see your API's JSON response for the `/`
route:

```json
{
  "message": "Hello world"
}
```

Now open `http://localhost:8000/docs` and you'll see an automated docs page for your API.

Open the one `GET` route and you'll see some information about that route. Click `Try it out` and
then the `Execute` button and it'll send a `GET` request to your index route. You can see the
response body and headers.

It also includes a Curl example. You can copy this and run it in a terminal:

```
curl -X 'GET' \
  'http://localhost:8000/' \
  -H 'accept: application/json'
```

Run this command and you'll see the JSON response.

We can kill the server with `Ctrl + C`.

## Library API

Open up `lib/pybrary/server/__init__.py` in your editor and you'll see a skeleton FastAPI app. This
one is defined within a Python library and includes relative imports like `from ..models import Book`.
This allows us to neatly structure parts of our codebase and share code between different parts of
an application.

In vscode (and other context aware editors) you can usually `Ctrl` + click or `Cmd + click` on a
class or function name to go to its definition, even if it's in another file.

Here we have a route called `get_book`:

```python
@app.get("/books/{book_id}")
def get_book(book_id: int) -> Book:
    return utils.get_book(book_id)
```

Ignoring the decorator for a moment, the function takes a parameter called `book_id` (an integer),
and returns type `Book` which is a Pydantic model defined in `models` elsewhere in the library. It
The actual return value of the function is the result of another function called `get_book` defined
in the `utils` file within the library.

The decorator defines the route as `/books/{book_id}`, which includes a variable `book_id`. When a
request matching the pattern `/books/{value}` is received, this function is called with that value
passed in as `book_id`. So a request to `/books/1` is like calling `get_book(1)`.

Let's spin up this API. We'll use `uvicorn`, a lightweight web server. First we need to configure
some settings. Create a file called `.env` in the root of the repo and add an environment variable
called `PYB_BOOKS_DIR` path to the `books` directory like so:

```
PYB_BOOKS_DIR=/home/ben/Projects/bennuttall/pydantic-workshop/books
```

Run `pwd` in the root of the repo to get your actual path.

There's a `make` command in the root of the repo that launches the API, so run `make serve`.
The command it's running is:

```
uvicorn --reload --reload-dir . --host 0.0.0.0 --port 8000 pybrary.server:app
```

So you can run this directly if you wish.

This ensures that any changes made to the code force the server to automatically reload the API.

Let's send a request to `http://localhost:8000/books/1` in the browser and see what happens.

We get a JSON response in the schema of the `Book` model as defined with Pydantic. The actual
contents are from the file `1.json` in the `books` directory.

The value is parsed by Pydantic as an integer, so if the value is not parseable as an integer, we'll
see an error. Try it and see!

We get a detailed JSON response explaining the error!

```json
{
  "detail": [
    {
      "type": "int_parsing",
      "loc": [
        "path",
        "book_id"
      ],
      "msg": "Input should be a valid integer, unable to parse string as an integer",
      "input": "bob"
    }
  ]
}
```

## HTTP status

Now let's try `http://localhost:8000/books/2` and see what happens.

We get an **Internal Server Error**.

Let's look at the server logs to see what happened. Open the terminal where you ran the server from.

We can see:

```
INFO:     127.0.0.1:42372 - "GET /books/2 HTTP/1.1" 500 Internal Server Error
```

and then a big stack trace ending with:

```
FileNotFoundError: [Errno 2] No such file or directory: '/home/ben/Projects/bennuttall/pydantic-workshop/books/2.json'
```

So here it tried to open `2.json` and did not find the file. Since there's no error handling, it
just crashed and returned a **500** error. Note that the server is still running!

Since this is a forseeable error, we can add a handler for it.