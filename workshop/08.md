# FastAPI server

## Hello world

FastAPI is an easy-to-use web framework for building APIs with Python.

It's built on Starlette and Pydantic. Starlette is a lightweight HTTP framework, and Pydantic
provides the data modelling.

Create a file `api.py`:

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def index():
    return {"message": "Hello world"}
```

Now let's run `fastapi dev api.py` and we should see the FastAPI dev server running.

Open `http://localhost:8000` in a browser and we should see our API's JSON response for the `/`
route:

```json
{
  "message": "Hello world"
}
```

Now let's open `http://localhost:8000/docs` and we'll see an automated docs page for our API.

If we open the one `GET` route we'll see some information about that route. If we click `Try it out`
and then the `Execute` button and it'll send a `GET` request to our index route. We can see the
response body and headers.

It also includes a Curl example. We can copy this and run it in a terminal (in another shell):

```
curl -X 'GET' \
  'http://localhost:8000/' \
  -H 'accept: application/json'
```

We can kill the server with `Ctrl + C`.

## Library API

If we open up `lib/pybrary/server/__init__.py` in our editor and we'll see a skeleton FastAPI app.
This one is defined within a Python library and includes relative imports like:

```python
from ..models import Book
```

This allows us to neatly structure parts of our codebase and share code between different
parts of an application.

*In vscode (and other context aware editors) you can usually `Ctrl` + click or `Cmd + click` on a
class or function name to go to its definition, even if it's in another file.*

Here we have a route called `get_book`:

```python
@app.get("/books/{book_id}")
def get_book(book_id: int) -> Book:
    return utils.get_book(book_id)
```

Ignoring the decorator for a moment, the function takes a parameter called `book_id` (an integer),
and returns type `Book` which is a Pydantic model defined in `models` elsewhere in the library. It
The actual return value of the function is the result of another function called `get_book` defined
in the `utils` file within the library.

The decorator defines the route as `/books/{book_id}`, which includes a variable `book_id`. When a
request matching the pattern `/books/{value}` is received, this function is called with that value
passed in as `book_id`. So a request to `/books/1` is like calling `get_book(1)`.

Let's spin up this API. We'll use `uvicorn`, a lightweight web server. First we need to configure
some settings. Create a file called `.env` in the root of the repo and add an environment variable
called `PYB_BOOKS_DIR` path to the `books` directory like so:

```
PYB_BOOKS_DIR=/home/ben/Projects/bennuttall/pydantic-workshop/books
```

*Run `pwd` in the root of the repo to get your actual path.*

There's a `make` command in the root of the repo that launches the API, so run `make serve`.
The command it's running is:

```
uvicorn --reload --reload-dir . --host 0.0.0.0 --port 8000 pybrary.server:app
```

So you can run this directly if you wish.

This ensures that any changes made to the code force the server to automatically reload the API.

Let's send a request to `http://localhost:8000/books/1` in the browser and see what happens.

We get a JSON response in the schema of the `Book` model as defined with Pydantic. The actual
contents are from the file `1.json` in the `books` directory.

The value is parsed by Pydantic as an integer, so if the value is not parseable as an integer, we'll
see an error. Try it and see!

We get a detailed JSON response explaining the error!

```json
{
  "detail": [
    {
      "type": "int_parsing",
      "loc": [
        "path",
        "book_id"
      ],
      "msg": "Input should be a valid integer, unable to parse string as an integer",
      "input": "bob"
    }
  ]
}
```

## Error handling

Now let's try `http://localhost:8000/books/2` and see what happens.

We get an **Internal Server Error**.

Let's look at the server logs to see what happened. Open the terminal where you ran the server from.

We can see:

```
INFO:     127.0.0.1:42372 - "GET /books/2 HTTP/1.1" 500 Internal Server Error
```

and then a big stack trace ending with:

```
FileNotFoundError: [Errno 2] No such file or directory: '/home/ben/Projects/bennuttall/pydantic-workshop/books/2.json'
```

So here it tried to open `2.json` and did not find the file. Since there's no error handling, it
just crashed and returned a **500** error. Note that the server is still running!

Since this is a forseeable error, we can add a handler for it.

First let's change our utility function to handle the case where the file is not found:

```python
def get_book(book_id: int) -> Book | None:
    book_path = settings.books_dir / f"{book_id}.json"
    if not book_path.exists():
        return None
    return Book.model_validate_json(book_path.read_text())
```

This now returns `None` if the book doesn't exist.

FastAPI provides an easy way to return specific HTTP codes. We can import `HTTPException` and return
one of these instead of a Pydantic model. Import it:

```python
from fastapi import FastAPI, HTTPException
```

Now we need to change our `get_book` route function to handle the case that `utils.get_book()`
returns `None`:

```python
def get_book(book_id: int) -> Book:
    book = utils.get_book(book_id)
    if book is None:
        raise HTTPException(status_code=404, detail="Book not found")
    return book
```

Now the API route will either return the `Book` model or raise a 404 error.

Try if we send a request for book 2 now, and we'll get:

```json
{
  "detail": "Book not found"
}
```

## POST

Next we'll add a route to add a new book.

First we'll need a utility function to create the new JSON file, given a `Book` model. Let's add
this to `utils`:

```python
def get_next_book_id() -> int:
    existing_ids = [int(p.stem) for p in settings.books_dir.glob("*.json") if p.stem.isdigit()]
    return max(existing_ids, default=0) + 1

def add_book(book: Book) -> Book:
    book_id = get_next_book_id()
    book_path = settings.books_dir / f"{book_id}.json"
    book_path.write_text(book.model_dump_json(indent=2))
    return book
```

Next we'll add a `POST` route to the API:

```python
@app.post("/books/")
def create_book(book: Book) -> Book:
    return utils.add_book(book)
```

Now if we head to the docs page at `http://localhost:8000/docs` and we'll see our new `POST` route
in a different colour to the existing `GET` routes. If we open it up we can see the route takes a
request body, the schema of which is defined by that of the `Book` model.

We can't easily send a `POST` request in the browser without setting up an HTML form, but we can use
the docs page. If we click `Try it out`, we can enter the values for the fields for our new book,
and hit `Execute` to send the request which the server will then process:

```json
{
  "title": "Architecture Patterns with Python",
  "author": "Harry Percival",
  "year_published": 2020
}
```

When we send that request we get the same body back in a **HTTP 200** response.

We can now retrieve book 2 from `/books/2`.

## PUT

Next we'll add a route to update an existing book.

First we'll add the utility function:

```python
def update_book(book_id: int, book: Book) -> Book | None:
    book_path = settings.books_dir / f"{book_id}.json"
    if not book_path.exists():
        return None
    book_path.write_text(book.model_dump_json(indent=2))
    return book
```

Next we'll add a `PUT` route to the API:

```python
@app.put("/books/{book_id}")
def update_book(book_id: int, book: Book) -> Book:
    updated_book = utils.update_book(book_id, book)
    if updated_book is None:
        raise HTTPException(status_code=404, detail="Book not found")
    return updated_book
```

Now we can send a `PUT` request to `http://localhost:8000/books/2` to replace the contents saved for
book 2. Again, we can't do this in the browser but can send a request via the docs page.

## DELETE

Next we'll add a route to delete a book.

First we'll add the utility function:

```python
def delete_book(book_id: int) -> bool:
    book_path = settings.books_dir / f"{book_id}.json"
    if not book_path.exists():
        return False
    book_path.unlink()
    return True
```

Next we'll add a `DELETE` route to the API:

```python
@app.delete("/books/{book_id}")
def delete_book(book_id: int):
    success = utils.delete_book(book_id)
    if not success:
        raise HTTPException(status_code=404, detail="Book not found")
    return {"message": "Book deleted successfully"}
```

Now we can send a `DELETE` request to `http://localhost:8000/books/2` to delete book 2. Again, we
can't do this in the browser but can send a request via the docs page.

## Exercise

- Add more fields to your `Book` model
- Add a route to retrieve a list of all books
- Add a route to list all authors and their books

Refer to the FastAPI docs for more info: https://fastapi.tiangolo.com/

See an example of a CLI I made with Typer:
- Docs: https://hostedpi.readthedocs.io/en/stable/cli/index.html
- Code: https://github.com/piwheels/hostedpi/tree/main/hostedpi/cli