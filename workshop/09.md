# FastAPI client

We can also make a request to our API using Python. Let's start with a simple GET request to our
index route:

```python
import requests

url = "http://localhost:8000"

r = requests.get(url)
```

Now inspect the response:

```
>>> r
<Response [200]>
```

And look at the JSON in the response:

```
>>> r.json()
{'message': 'Hello world'}
```

Let's send a request to fetch one of our books:

```python
book_url = f"{url}/books/2"

r = requests.get(book_url)
```

So we can send requests and get back JSON. Wouldn't it be nice if we could parse the JSON into a
Pydantic model...

```python
class Book(BaseModel):
    ...
```

Wait! Don't we already have these defined somewhere?

If we're consuming a third-party API, we may need to write our own Pydantic models, but if the API
is *ours*, we can share the API server's models accessible to any clients wishing to consume from
that API to make things easier. In a really simple example of this, our `pybrary` lib has a nice
structure to demonstrate this concept. We have `server`, `client` and `models`, meaning both the
server code and the client code can import from `models`.

Let's check out the starter code in the `client` submodule:

```python
from requests import Session

from ..models import Book
from .settings import get_settings


class PybraryApiClient:
    def __init__(self):
        self.settings = get_settings()
        self.url = str(self.settings.api_url)
        self.session = Session()

    def get_book(self, book_id: int) -> Book:
        url = f"{self.url}/books/{book_id}"
        response = self.session.get(url)
        response.raise_for_status()
        return Book.model_validate(response.json())
```

Here we have a `PybraryApiClient` class, which has a requests session, and a `url` from settings. It
has a single method `get_book` which returns a `Book` which came from the shared `models` submodule.
That method sends an API request and returns a validated `Book` model instance. So we can create a
client instance and simply call a method to send a specific request and have it return a known
structure defined by our model.

We can add more methods and provide a nice client library.

## Exercise

Look at what settings are required for the client, test it out and add more methods.