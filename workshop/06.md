# pydantic-settings

pydantic-settings lets you define application settings as Pydantic models, automatically loading
values from environment variables, .env files, or other sources.

```python
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    url: str
```

We *can* use this like a normal Pydantic model:

```python
>>> Settings(url="https://www.google.com")
```

But if we set the environment variable `URL` before running the Python interpreter, that value will
be parsed automatically:

```
$ URL=https://www.google.com/ python
Python 3.13.6 (main, Aug  6 2025, 13:05:20) [Clang 17.0.0 (clang-1700.0.13.3)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> from pydantic_settings import BaseSettings
>>> class Settings(BaseSettings):
...     url: str
...     
>>> Settings()
Settings(url='https://www.google.com/')
```

For persistent system settings, we might want to set environment variables somewhere like `.bashrc`
or `.zshrc`, and they will be loaded automatically (as long as the shell is reloaded after updating
these files).

Another approach is to set environment variables in a `.env` file:

```
URL=https://www.google.com/
```

## Settings config

With this file saved as `.env`, settings can be loaded from here if we configure the `Settings`
class using `SettingsConfigDict`:

```python
from pydantic_settings import BaseSettings, SettingsConfigDict

class Settings(BaseSettings):
    model_config = SettingsConfigDict(env_file=".env")

    url: str
```

We can also specify a prefix, so that settings are scoped to environment variables with a given
prefix:

```python
class Settings(BaseSettings):
    model_config = SettingsConfigDict(env_file=".env", env_prefix="foo_")

    url: str
```

Now the environment variable will need to be called `FOO_URL`, but the field wil still just be
called `url`, and accessed as `settings.url`.

## Validators

We can also use validators with our `Settings` object:

```python
from pydantic_settings import BaseSettings, SettingsConfigDict
from pydantic import model_validator, field_validator

class Settings(BaseSettings):
    app_name: str = "MyApp"
    debug: bool = False
    port: int = 8000
    log_level: str = "INFO"

    @field_validator("log_level", mode="after")
    def ensure_uppercase(cls, v: str) -> str:
        return v.upper()

    @model_validator(mode="after")
    def check_debug_and_log_level(self):
        if self.debug and self.log_level == "ERROR":
            raise ValueError("Cannot run with debug=True and log_level='ERROR'")
        return self
```

## Pydantic types

It's common to see pydantic-settings rely on Pydantic types such as `FilePath`, `AnyHttpUrl`,
`PositiveInt` and so on, as well as `field_validator` and `model_validator`. Simply import these
from `pydantic` alongside `pydantic_settings`:

```python
from pydantic import (
    BaseModel,
    DirectoryPath,
    FilePath,
    field_validator,
    model_validator,
)
from pydantic_settings import BaseSettings, SettingsConfigDict
```

## Settings from YAML

In some projects it may be better to declare them in a more structured format like a YAML file, and
parse them in using a nested model. In this case, a good pattern may be to use pydantic-settings
to parse the path to the YAML file, and use a regular Pydantic model to parse the structure of the
parsed YAML file.

For example in my static site generator [Beemo](https://github.com/bennuttall/beemo) I use the
following `Settings` class:

```python
class Settings(BaseSettings):
    model_config = SettingsConfigDict(env_file=".env", env_prefix="beemo_")

    config: FilePath
```

I also define a `Config` class as a regular Pydantic model:

```python
class Config(BaseModel):
    ...
```

And I use a `get_config` function which uses the value of the environment variable `BEEMO_CONFIG`
(a YAML file), loads the YAML contents into a dict and validates it as a `Config` model:

```python
@cache
def get_config() -> Config:
    settings = Settings()
    with open(settings.config, "r") as f:
        config = yaml.safe_load(f)
    return Config.model_validate(config)
```

Note it can be a good idea to create a cached function for `get_settings` or `get_config` to
prevent it being loaded and parsed multiple times.
