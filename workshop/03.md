# Collections

Instead of a single value, a field may require multiple values, such as a book having multiple
authors.

In this case we can use `list` as the type, and specify that it's a list of strings:

```python
class Book(BaseModel):
    title: str
    authors: list[str]
```

We simply pass in a list of values for `authors`:

```python
Book(
    title="The Pragmatic Programmer",
    authors=["Andrew Hunt", "Dave Thomas"],
)
```

## Nested models

If we wanted to specify a field with its own schema, rather than a single value or a list of values,
we can define this field type as a separate model.

For example, instead of book authors only being represented by a string, we could define an `Author`
model:

```python
class Author(BaseModel):
    name: str
    dob: date | None = None
```

Now we can use this rich `Author` model as the `Book` model's `author` field type:

```python
class Book(BaseModel):
    title: str
    author: Author

book = Book(
    title="Pragmatic Programmer",
    author=Author(name="Andrew Hunt", dob="1964-12-27"),
)
```

And we can access `book.author.name` and `book.author.dob`.

We can also use a list of authors the same way:

```python
class Book(BaseModel):
    title: str
    authors: list[Author]

book = Book(
    title="Pragmatic Programmer",
    authors=[
        Author(name="Andrew Hunt", dob="1964-12-27"),
        Author(name="Dave Thomas", dob="1960-01-04"),
    ]
)
```

And access the `book.authors` list items:

```python
>>> andrew = book.authors[0]
>>> andrew.name
'Andrew Hunt'
```

or iterate over the list:

```python
for author in book.authors:
    print(author.name, author.dob)
```