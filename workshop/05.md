# Field validation

Sometimes we need extra validation as well as simple type coercion. Field validators allow us to
add simple (or complex) logic to validate values on particular fields.

## mode = after

For example, `page` is an integer but so are `0` and `-1`, and they're not a valid number of pages.
Adding a field validator allows us to check its value:

```python
from pydantic import BaseModel, field_validator

class Book(BaseModel):
    title: str
    author: str
    pages: int
    price: float
    published: date

    @field_validator("pages", mode="after")
    def pages_must_be_positive(cls, v):
        if v <= 0:
            raise ValueError("A book must have at least one page")
        return v
```

We can create a `Book` with valid fields, but now if we try to create a `Book` with an invalid
number of pages, we get a `ValidationError` with our specific error message:

```python
>>> Book(
    title="Clean Code",
    author="Robert C. Martin",
    pages=-464,
    price="29.99",
    published="2008-08-01",
)

ValidationError: 1 validation error for Book
pages
  Value error, A book must have at least one page [type=value_error, input_value=-464, input_type=int]
    For further information visit https://errors.pydantic.dev/2.11/v/value_error
```

Note we must either return a value or raise an exception. If an exception is raised, this causes
a `ValidationError`. If a value is returned, that value set as the field's value.

In this example we wanted our validator to be run *after* parsing as an integer, so we used
`mode="after"`.

## mode = before

Sometimes what we want to do is clean input *before* parsing. If we pass in a string that's going to
be turned into an integer, we might want to ensure no whitespace from the string remains before
converting to an integer, so we use `mode="before"`:

```python
class Book(BaseModel):
    title: str
    author: str
    pages: int
    price: float
    published: date

    @field_validator("pages", mode="before")
    def strip_whitespace(cls, v):
        return v.strip()
```

Here is an example showing both *before* and *after* field validators together to see what happens
to the value as it passes through each validator:

```python
class Example(BaseModel):
    age: int

    @field_validator("age", mode="before")
    def see_raw(cls, v):
        print("BEFORE sees:", repr(v))
        return v

    @field_validator("age", mode="after")
    def see_parsed(cls, v):
        print("AFTER sees:", repr(v))
        return v

Example(age="123")
```

The output shows:

```
BEFORE sees: '123'
AFTER sees: 123
```

The value was still a string when passed to `see_raw`, and was an integer when passed to
`see_parsed`.

## mode = wrap

A third mode is available, `mode="wrap"` which takes the raw value like `mode="before"`, but allows
you to control the type coercion step, optionally calling `handler` which is what Pydantic would
have done itself:

```python
class User(BaseModel):
    age: int

    @field_validator("age", mode="wrap")
    def wrap_validator(cls, v, handler):
        print("raw input:", v)
        value = handler(v)
        print("parsed:", value)
        return value
```

## Constrained types

Alternatively to using field validators, many common validations are available as contrained types,
such as `PositiveInt`:

```python
from pydantic import PositiveInt

class Book(BaseModel):
    title: str
    author: str
    pages: PositiveInt
    price: float
    published: date
```

Now there is no need for a field validator, unless we want to customise the error message, which
could be different for 0 or a negative number.

Another field constraint can be to use `Literal` with a defined set of values:

```python
from typing import Literal

from pydantic import PositiveInt

class Book(BaseModel):
    kind: Literal["fiction", "non-fiction", "reference"]
```

## Enums

We can also use enums, which might be useful if we already have one defined in a library:

```python
from enum import Enum

class Status(str, Enum):
    IN_STOCK = "IN STOCK"
    OUT_OF_STOCK = "OUT OF STOCK"
    DISCONTINUED = "DISCONTINUED"

class Product(BaseModel):
    status: Status
```

The difference between a `Literal` field and an `Enum` field is that a `Literal` field will just be
a plain value (e.g. a string) and the `Enum` field will be an `Enum` object:

```python
>>> book = Book(kind="fiction")
>>> book.kind
'fiction'
>>> product = Product(status="IN STOCK")
>>> product.status
<Status.IN_STOCK: 'IN STOCK'>
>>> product.status.name
'IN_STOCK'
>>> product.status.value
'IN STOCK'
```

You can also pass the Enum member directly:

```python
>>> product = Product(status=Status.IN_STOCK)
>>> product.status
<Status.IN_STOCK: 'IN STOCK'>
>>> product.status.name
'IN_STOCK'
>>> product.status.value
'IN STOCK'
```